\section{Erweiterung auf Graphen im zweidimensionalen Raum}
\label{raeumliche_erweiterung}

\citeauthor{patchy} haben einen Algorithmus zur Generierung von Receptive-Fields über den Nachbarschaften eines Graphen vorgestellt, der effizient implementiert werden kann und über einer Reihe von Testdatensätzen konkurrenzfähige Resultate im Vergleich zu Methoden, die auf \emph{Graphkernen} basieren, liefert (\vgl{}~\cite{patchy}).
Dabei hängt die Ordnung der Knotenauswahl und der Receptive-Fields stark von einer gewählten Zentralitätsmetrik ab, die auf einem allgemeinen Graphen $\gls{G} = \left(\gls{V}, \gls{E}\right)$ eine fehlende räumliche oder zeitliche Ordnung ersetzt.
Im Kontext von Graphen im zweidimensionalen euklidischen Raum $\gls{G} = \left(\gls{V}, \gls{E}, \gls{p}\right)$, bei denen den Knoten jeweils eine eindeutige Position in der Ebene zugeordnet werden kann, kann die Knotenauswahl $\gls{V}_{\mathrm{out}}$ (Algorithmus~\ref{alg:knotenauswahl}) sowie die Normalisierung der Nachbarschaftsmenge $\gls{N}_{\gls{v}}$ eines Knotens $\gls{v} \in \gls{V}_{\mathrm{out}}$ diese folglich berücksichtigen.
Dies erscheint insbesondere dann sinnvoll, wenn sich ein Graph durch viele gleichwertig zentrale Knoten auszeichnet.
So bildet ein Graph, der durch eine \gls{SLIC}-Segmentierung generiert wurde, (in etwa) auf ein unstrukturiertes Gitter ab.
Eine Zentralitätsmetrik auf diesem Graphen besitzt so gut wie keine Aussagekraft.
Der Graph zeichnet sich dabei eher durch seine Positionen der Knoten in der Ebene aus.

Die Knotenauswahl wird folglich über die Anordnung der Knoten \bzgl{} ihrer \emph{Scanline}-Ordnung beschrieben, \dhe{} von oben nach unten und von links nach rechts.
Formal lässt sich dafür die Knotenfärbung $\gls{l}_{\mathrm{scanline}} \colon \gls{V} \to \gls{R}$ über
\begin{equation*}
  {\gls{l}_{\mathrm{scanline}}\left(\gls{v}\right)}^{-1} \coloneqq w_{\max} \, {\hat p\left(\gls{v}\right)}_1 + {\hat p\left(\gls{v}\right)}_2
\end{equation*}
mit dem maximalen Breitenabstand $w_{\max} \coloneqq \max_{\gls{v}_i, \gls{v}_j \in \gls{V}} \left({\gls{p}\left(\gls{v}_i\right)}_2 - {\gls{p}\left(\gls{v}_j\right)}_2 \right)$ und der normalisierten Position
\begin{equation*}
  \hat p\left(\gls{v}\right) \coloneqq {\left[\left\lfloor\frac{{\gls{p}\left(\gls{v}\right)}_1 - y_{\min}}{\delta} \right\rfloor, {\gls{p}\left(\gls{v}\right)}_2 - x_{\min}\right]}^{\top}
\end{equation*}
mit $y_{\min} \coloneqq \min \left({\gls{p}\left(\gls{v}_1\right)}_1, \ldots, {\gls{p}\left(\gls{v}_N\right)}_1\right)$ \bzw{} $x_{\min} \coloneqq \min \left({\gls{p}\left(\gls{v}_1\right)}_2, \ldots, {\gls{p}\left(\gls{v}_N\right)}_2\right)$ und $\delta \in \gls{R+}$ definieren, sodass Knoten einen höheren Farbwert erhalten, umso geringer ihre $y$-Koordinate ist und bei annäherend gleicher $y$-Koordinate ihre $x$-Koordinate die Farben weiter differenziert.
Dafür werden die jeweiligen Positionen $\gls{p}\left(\gls{v}\right)$ mittels $\hat p\left(\gls{v}\right)$ in den positiven reellen Raum transformiert.
Die $y$-Koordinate von $\hat p$ wird weiter auf eine über $\delta$ steuerbare natürliche Zahl gerundet.
Dadurch werden kleine Fluktuationen in den $y$-Koordinaten ausgeglichen, die ansonsten eine vollkommen willkürliche Ordnung erzeugen würden.
Die $y$-Koordinate von $\hat p\left(\gls{v}\right)$ wird in $\gls{l}_{\mathrm{scanline}}$ daraufhin insofern gewichtet, dass für zwei unterschiedliche $y$-Koordinaten die Ordnung, die die Knotenfärbung generiert, nicht von der $x$-Koordinate beeinflusst wird.
Damit entspricht der Algorithmus~\ref{alg:knotenauswahl} mit der Knotenfärbung $\gls{l}_{\mathrm{scanline}}$ in etwa der Pixelauswahl einer klassischen Faltung auf regulären Gittern, mit dem Unterschied, dass die Knotenauswahl letztendlich eine eindimensionale geordnete Menge definiert.
Das ist aufgrund der möglichen Irregularitäten in den jeweiligen Knotenpositionen allerdings nicht zu vermeiden.
Folglich sind benachbarte Knoten in $\gls{V}_{\mathrm{out}}$ nicht zwangsläufig auch in der Ebene benachbart.
$\gls{l}_{\mathrm{scanline}}$ generiert jedoch eine Knotenfärbung, die für zwei strukturell gleiche Graphen eine ähnliche Ordnung generiert.

Die Generierung eines Receptive-Fields nach der vorgestellten Methode in Algorithmus~\ref{alg:nachbarschaftsgruppierung} und~\ref{alg:normalisierung} ordnet die Knoten allen voran anhand ihrer Abstände zum Wurzelknoten.


Für die Generierung des Receptive-Fields


% Wir wollen, dass benachbarte Knoten im Receptive-Field ebenfalls benachbart im Bild sind

% beachtet keine Gewichte
% beatchtet keine Positionen
% im Kontext von Graphen im zweidimensionalen  euklidischen  Raum stehen uns diese aber zur Verfügung und sollten dementsprechen genutzt werden.
% Dafür wird das zuvor beschrieben Prinzip angepasst.

% Als Knotenauswahl wählen wir Stackline-Order?
% Für die Nachbarschaftsauswahl kombinieren wir die Auswahl und dessen Normalisierung zu einem Schritt.
% Spriale

% Für die Neighborhood Assembly eines Knotens wurde ein spezieller Algorithmus implementiert, der die nächsten Knoten um den Rootknoten ähnlich wie bei einer Spirale einsammelt.

% Dies wurde implementiert, da der eigentliche Gedanke, eine Convolution auf Basis des Grids, das SLIC erzeugt, nicht möglich ist. Es ist daher nicht möglich, da SLIC kein vollkommenes Grid erzeugt. Es werden teilweise Knoten hinzugefügt oder entfernt, wenn dies sinnvoll erscheint. Damit spuckt SLIC auch immer nur eine approximierte Anzahl an Segmenten aus, die gewünscht waren.

% Der Grid-Spiral-Algorithmus funktioniert wie folgt:

% Der Root Knoten ist immer an Index 0.
% Es wird der nächstgelegene Nachbar zum Rootknoten gesucht und der Neighborhood angehängt.
% Es wird wiederholt ein Nachbar y zum letzten hinzugefügten Knoten x gesucht, sodass $w(x, y)$ + $w(root, y)$ minimal.

\begin{algorithm}[t]
\centering
\begin{algorithmic}
  \REQUIRE{}
  \ENSURE{}
\end{algorithmic}
\caption[]{}
\label{alg:spirale}
\end{algorithm}
